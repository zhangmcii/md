# 数据库中的 聚簇索引 VS 非聚簇索引

还不清楚索引知识点的，可以去看看上一节的**索引**


## 聚簇索引是什么？
⭐ 聚簇索引 = 数据按照索引顺序直接存储在叶子节点里。 
也就是说，叶子节点 = 真实数据行（不是指针，而是整个数据行！）

## 非聚簇索引是什么？
⭐ 非聚簇索引 = 叶子节点存的不是数据行，而是主键值。 也就是说，叶子节点 = (索引列值, 主键值)
查数据时必须： 先查非聚簇索引 → 拿到主键 → 回到聚簇索引查真实行 。这一过程叫**回表**。


Mysql在V5.1之前默认存储引擎是MyISAM， 在此之后默认存储引擎是InnoDB。
InnoDB 中主键索引默认就是聚簇索引，MyISM使用的是非聚簇索引

## 它们是怎么利用 B+ 树来存储数据的？
举一个简单的例子：
假设你有一个学生表：
```
CREATE TABLE student (
    id INT PRIMARY KEY,
    name VARCHAR(20),
    age INT
);
```
我们插入以下数据：
| id | name | age |
| -- | ---- | --- |
| 1  | Tom  | 18  |
| 3  | Bob  | 20  |
| 5  | Ann  | 19  |

再加一个二级索引：
```
CREATE INDEX idx_name ON student(name);
```

现在我们有：
主键（id） → 聚簇索引
name → 非聚簇索引

下面是一个聚簇索引的 B+ 树（逻辑示意图）：
```
            [3]
         /        \
       /            \
[1, (row1)]   [3, (row2)]   [5, (row3)]
```

这里注意： 叶子节点内容是 “整行数据”：
```
[1, ("Tom", 18)]
[3, ("Bob", 20)]
[5, ("Ann", 19)]
```
这就是聚簇索引的特征：叶子节点存完整数据行


非聚簇索引（name 字段）的 B+ 树（逻辑示意图）：
我们根据 name 字典序：
| name | id |
| ---- | -- |
| Ann  | 5  |
| Bob  | 3  |
| Tom  | 1  |

非聚簇索引 B+ 树示意：
```
           [Bob]
         /       \
       /           \
[Ann, 5]    [Bob, 3]    [Tom, 1]
```
注意叶子节点都是： (name, 主键 id)。
并没有存其它列，如 age。

## 利用聚集索引和非聚集索引查找数据
InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 5"这样的条件查找主键，
则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。

通过非聚簇索引查 name = 'Bob'
1. 用 name 索引找到： (Bob, 3)， 我们得到主键 id = 3
2. 回到聚簇索引查主键 3：
聚簇索引叶子页面里找到完整数据：id = 3, name = Bob, age = 20 （这个过程叫**回表**）


## 结论：
在mysql的innoDB存储引擎中
1.我们建表时设置的主键（一般为 id）是聚簇索引（唯一的）
2.**后期添加的**所有索引全部都是非聚簇索引


## 疑问？
1.上面得到的结论说聚簇索引是唯一的，为什么不能再创建第二个聚簇索引？
答：因为 **聚簇索引就是数据的物理存储顺序**。
数据在磁盘中按主键顺序排好，如果你再要一个聚簇索引，就需要再存一份整表数据，这是不现实的。
MySQL（InnoDB）表只有一份真实数据，所以只能有一个聚簇索引。

2.为什么主键通常建议使用自增id？
答：聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。
如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。
但如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。

因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。
聚簇索引则只需一次I/O。（强烈的对比）


> 聚簇索引：以innodb作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。  
                这是因为innodb是把数据存放在B+树中的，而B+树的键值就是主键，在B+树的叶子节点中，存储了表中所有的数据。
                这种以主键作为B+树索引的键值而构建的B+树索引，我们称之为聚集索引。
  非聚簇索引：以主键以外的列值作为键值构建的B+树索引，我们称之为非聚集索引。 非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，
            而是存储该列对应的主键， 想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。







⭐ 聚簇索引 = 数据按照索引顺序直接存储在叶子节点里。 
也就是说，叶子节点 = 真实数据行（不是指针，而是整个数据行！）

## 非聚簇索引是什么？
⭐ 非聚簇索引 = 叶子节点存的不是数据行，而是主键值。 也就是说，叶子节点 = (索引列值, 主键值)
查数据时必须： 先查非聚簇索引 → 拿到主键 → 回到聚簇索引查真实行 。这一过程叫**回表**。


Mysql在V5.1之前默认存储引擎是MyISAM， 在此之后默认存储引擎是InnoDB。
InnoDB 中主键索引默认就是聚簇索引，MyISM使用的是非聚簇索引

## 它们是怎么利用 B+ 树来存储数据的？
举一个简单的例子：
假设你有一个学生表：
```
CREATE TABLE student (
    id INT PRIMARY KEY,
    name VARCHAR(20),
    age INT
);
```
我们插入以下数据：
| id | name | age |
| -- | ---- | --- |
| 1  | Tom  | 18  |
| 3  | Bob  | 20  |
| 5  | Ann  | 19  |

再加一个二级索引：
```
CREATE INDEX idx_name ON student(name);
```

现在我们有：
主键（id） → 聚簇索引
name → 非聚簇索引

下面是一个聚簇索引的 B+ 树（逻辑示意图）：
```
            [3]
         /        \
       /            \
[1, (row1)]   [3, (row2)]   [5, (row3)]
```

这里注意： 叶子节点内容是 “整行数据”：
```
[1, ("Tom", 18)]
[3, ("Bob", 20)]
[5, ("Ann", 19)]
```
这就是聚簇索引的特征：叶子节点存完整数据行


非聚簇索引（name 字段）的 B+ 树（逻辑示意图）：
我们根据 name 字典序：
| name | id |
| ---- | -- |
| Ann  | 5  |
| Bob  | 3  |
| Tom  | 1  |

非聚簇索引 B+ 树示意：
```
           [Bob]
         /       \
       /           \
[Ann, 5]    [Bob, 3]    [Tom, 1]
```
注意叶子节点都是： (name, 主键 id)。
并没有存其它列，如 age。

## 利用聚集索引和非聚集索引查找数据
InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 5"这样的条件查找主键，
则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。

通过非聚簇索引查 name = 'Bob'
1. 用 name 索引找到： (Bob, 3)， 我们得到主键 id = 3
2. 回到聚簇索引查主键 3：
聚簇索引叶子页面里找到完整数据：id = 3, name = Bob, age = 20 （这个过程叫**回表**）


## 结论：
在mysql的innoDB存储引擎中
1.我们建表时设置的主键（一般为 id）是聚簇索引（唯一的）
2.**后期添加的**所有索引全部都是非聚簇索引


## 疑问？
1.上面得到的结论说聚簇索引是唯一的，为什么不能再创建第二个聚簇索引？
答：因为 **聚簇索引就是数据的物理存储顺序**。
数据在磁盘中按主键顺序排好，如果你再要一个聚簇索引，就需要再存一份整表数据，这是不现实的。
MySQL（InnoDB）表只有一份真实数据，所以只能有一个聚簇索引。

2.为什么主键通常建议使用自增id？
答：聚簇索引的数据的物理存放顺序与索引顺序是一致的，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。
如果主键不是自增id，那么可以想象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。
但如果是自增的，那就简单了，它只需要一页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。

因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。
聚簇索引则只需一次I/O。（强烈的对比）


> 聚簇索引：以innodb作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。  
                这是因为innodb是把数据存放在B+树中的，而B+树的键值就是主键，在B+树的叶子节点中，存储了表中所有的数据。
                这种以主键作为B+树索引的键值而构建的B+树索引，我们称之为聚集索引。
  非聚簇索引：以主键以外的列值作为键值构建的B+树索引，我们称之为非聚集索引。 非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，
            而是存储该列对应的主键， 想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。






