## 移除元素

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
示例 1: 给定 nums = [3,2,2,3], val = 3, 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。 你不需要考虑数组中超出新长度后面的元素。
示例 2: 给定 nums = [0,1,2,2,3,0,4,2], val = 2, 函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

你不需要考虑数组中超出新长度后面的元素。

思路1： 遍历数组，若元素等于val，则该位置及后续元素全部左移
时间： O(n^2)
空间： O(1)



更优解法：
思路2：  双指针
双指针共同构建一个新的数组，由于题目要求是原地移除，所以新数组是基于旧的数组之上，而不是新申请一个数组。
快指针指向旧数组不等于val的值，慢指针将快指针s所指向的值来填充新数组，所以快指针的一次遍历，就可以得到不包含val值的数组，并且新数组的大小就是slow值。

时间： O(n)
空间： O(1)

```
int removeElement(int* nums, int size, int val){
    int slow = 0;
    for(int fast = 0;fast < size;fast++){
        if(nums[fast] != val){
            nums[slow++] = nums[fast];
        }
    }
    return slow;
}
```

## 反转字符串
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]

示例 2：
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]


思路1：创建大小相等的辅助数组，将原数组从后往前的值填放到辅助数组中，最后将辅助数组值写会原数组
时间： O(n)
空间： O(n)


`优化解法`：
思路2: 双指针
开始指向数组中间位置，设置一个字符变量为对换临时空间，然后兑换左右指针的值
数组元素个数为偶数，比如实例2： left = (size / 2) - 1 , right = (size / 2)
为奇数，比如实例1：  left = (size / 2) - 1 , right = (size / 2) + 1
置换次数：size / 2
时间： O(n)
空间： O(1)

```
void invert(char* array, int size){
    int left = (size / 2) - 1;
    int right = size % 2 == 0 ? (size / 2) : (size / 2) + 1;
    char temp;
    for(int i = 0;i < size / 2;i++){
        temp = array[right];
        array[right] = array[left];
        array[left] = temp;

        left--;
        right++;
    }
}
```


`更优解法`：
思路3: 定义两个指针（也可以说是索引下标），一个从字符串前面，一个从字符串后面，两个指针同时向中间移动，并交换元素。
时间： O(n)
空间： O(1)
```
void invert(char* array, int size){
    char temp;
    for(int left = 0, right = size -1;left < right;left++, right--){
        temp = array[right];
        array[right] = array[left];
        array[left] = temp;
    }
}
```

# 替换数字

给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。

例如，对于输入字符串 "a1b2c3"，函数应该将其转换为 "anumberbnumbercnumber"。

对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"

输入：一个字符串 s,s 仅包含小写字母和数字字符。

输出：打印一个新的字符串，其中每个数字字符都被替换为了number

样例输入：a1b2c3

样例输出：anumberbnumbercnumber

数据范围：1 <= s.length < 10000。



思路1: 遍历字符串，遇到数字，数字后面的字符右移6位，填入number。
时间： O(n^2)
空间： O(1)



思路2: 双指针
双指针构造一个新数组。
快指针遇到数字时，慢指针追加6个字符长度空间，在慢指针的位置将number填入，随后慢指针下标位置+6。
快指针遇到字符时，慢指针将快指针s所指向的值来填充新数组。

涉及到追加空间，一定会破坏遍历过程，所以新数组时需另外开辟空间。
时间： O(n)
空间： O(n)

注意： 提前扫描一遍字符串得到数字个数，不会增加额外的时间复杂度，因为是并列的操作，不是嵌套的for循环



思路3：双指针法
如果想把这道题目做到极致，就不要只用额外的辅助空间了！
1.首先扩充数组到每个数字字符替换成 "number" 之后的大小。
2.i指向新长度的末尾，j指向旧长度的末尾，然后从后向前替换数字字符
时间： O(n)
空间： O(1)


代码语法错误：
```
void replaceNumber(){
    const char* s = "number";
    char array[] = (char*)malloc(100 * sizeof(char));
    scanf("%s", &array);
    int i = strlen(array) - 1;
    int numberCount = 0;
    for(int i = 0;array[i] != '/0';i++){
        if(array[i] >= '0' && array[i] <= '9')
            numberCount++;
    }
    char newArray[] = relloc(array, numberCount * sizeof(char))
    if(newArray != NULL){
        int size = strlen(newArray);
        int j = size - 1;
        for(;i >= 0;i--){
            if(newArray[i] >= '0' && newArray[i] <= '9'){
                newArray[j--] = 'r';
                newArray[j--] = 'e';
                newArray[j--] = 'b';
                newArray[j--] = 'm';
                newArray[j--] = 'u';
                newArray[j--] = 'n';
            }else{
                newArray[j] = newArray[i];
                j--;
            }
        }
    }

}
```


正确写法：
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

void replaceNumber() {
    char *array = (char*)malloc(100 * sizeof(char));
    if (!array) return;

    scanf("%s", array);

    int oldLen = strlen(array);
    int numberCount = 0;

    // 统计数字数量
    for (int i = 0; i < oldLen; i++) {
        if (isdigit(array[i])) {
            numberCount++;
        }
    }

    // 扩容：每个数字多出5个字符
    char *newArray = realloc(array, (oldLen + numberCount * 5 + 1) * sizeof(char));
    if (newArray == NULL) {
        free(array);
        return;
    }

    int i = oldLen - 1;
    int j = oldLen + numberCount * 5 - 1;
    newArray[j + 1] = '\0';  // 添加结束符

    // 从后往前替换
    while (i >= 0) {
        if (isdigit(newArray[i])) {
            newArray[j--] = 'r';
            newArray[j--] = 'e';
            newArray[j--] = 'b';
            newArray[j--] = 'm';
            newArray[j--] = 'u';
            newArray[j--] = 'n';
        } else {
            newArray[j--] = newArray[i];
        }
        i--;
    }

    printf("%s\n", newArray);
    free(newArray);
}

int main() {
    replaceNumber();
    return 0;
}

```



## 翻转单词
给定一个字符串，逐个翻转字符串中的每个单词。

示例 1：
输入: "the sky is blue"
输出: "blue is sky the"

示例 2：
输入: "  hello world!  "
输出: "world! hello"
解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。

示例 3：
输入: "a good   example"
输出: "example good a"
解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。

思路1：先对整个字符串翻转，删除首尾空格，中间的空格，再对每个单词翻转即可。
删除首尾空格，中间的空格：删除左边的，需要将后面的元素左移
单词翻转：
while(s[i]!='\0'){
   while(s[j]!=' ')
     j++
   // i, j-1首位元素对换

   j++
   i=j
}

时间： O(n)
空间： O(1)

自己写的：
```
void invertWord(char *s){
    int size = strlen(s)
    char temp;
    for(int left = 0, right = size -1;left < size / 2;left++, right--){
        temp = s[right];
        s[right] = s[left];
        s[left] = temp;
    }
    // 删除空格
    int i = 0, j = 0;
    while(s[i] != '\0'){
        j = i;
        while(s[j] != ' ' && s[j] != '\0'){  // 找到单词的右边界
            j++;
        }
        int left = i, right = j - 1;
        while(left < right){  // 翻转单词
            char temp = s[left];
            s[left] = s[right];
            s[right] = temp;
            left++;
            right--;
        }
        if(s[j] == '\0') break; // 最后一个单词结束
        i = j + 1; // 移动到下一个单词起点
    }

}
```


删除首尾和中间空格：
思路：和在数组中移除元素逻辑是一样的
时间： O(n)
空间： O(1)

```
// 版本二
int removeExtraSpaces(char *s, size) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
    int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html
    for (int i = 0; i < size; ++i) {
        if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。
            if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
            while (i < size && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。
                s[slow++] = s[i++];
            }
        }
    }
    return slow   // slow的大小即为去除多余空格后的大小
}
```

思路2:
1.移除多余空格
2.将整个字符串反转
3.将每个单词反转
时间： O(n)
空间： O(1)

、
整体代码：
```
// 翻转字符串中指定范围的字符
void reverse(char* s, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        int tmp = s[i];
        s[i] = s[j];
        s[j] = tmp;
    }
}

// 删除字符串两端和中间多余的空格
int removeExtraSpaces(char *s, size) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。
    int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html
    for (int i = 0; i < size; ++i) {
        if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。
            if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。
            while (i < size && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。
                s[slow++] = s[i++];
            }
        }
    }
    return slow   // slow的大小即为去除多余空格后的大小
}

// 翻转字符串中的单词
char * reverseWords(char * s){
    removeExtraSpace(s, strlen(s)); // 先删除字符串两端和中间的多余空格
    reverse(s, 0, strlen(s) - 1); // 翻转整个字符串
    int slow = 0; // 指向每个单词的开头位置的指针
    for (int i = 0; i <= strlen(s); i++) { // 遍历整个字符串
        if (s[i] ==' ' || s[i] == '\0') { // 如果当前字符是空格或空字符，说明一个单词结束了
            reverse(s, slow, i-1); // 翻转单词
            slow = i + 1; // 将 slow 指针指向下一个单词的开头位置
        }
    }
    return s; // 返回处理后的字符串
}
```

点评： 此题综合考察了字符串的多种操作：
`移除多余空格`是 移除元素 逻辑，
`将整个字符串反转`和`将每个单词反转`是 反转字符串 逻辑。

## 反转链表
题意：反转一个单链表。
示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL


思路1： 头插法
时间： O(n)
空间： O(n)


如果再定义一个新的链表，实现链表元素的反转，其实这是对内存空间的浪费。
思路2:
首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。
然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。
为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。
接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。
最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。
时间： O(n)
空间： O(1)

双指针：
```
ListNode* reverseList(ListNode* head){
    //保存cur的下一个结点
    ListNode* temp;
    //pre指针指向前一个当前结点的前一个结点
    ListNode* pre = NULL;
    //用head代替cur，也可以再定义一个cur结点指向head。
    while(head) {
        //保存下一个结点的位置
        temp = head->next;
        //翻转操作
        head->next = pre;
        //更新结点
        pre = head;
        head = temp;
    }
    return pre;
}
```
## 两两交换链表中的节点
给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。
比如输入 1 -> 2 -> 3 -> 4，输出 2 -> 1 -> 4 -> 3。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。
![题目1](https://file1.kamacoder.com/i/algo/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-%E9%A2%98%E6%84%8F.jpg)


思路：遍历链表，设置一个临时节点，两两交换。
时间： O(n)
空间： O(1)
```
ListNode* swapNode(ListNode* head){
    ListNode *temp = NULL;
    ListNode *p = head, *next = p->next;
    while(next){
        swap(head, next);
        p = next->next;
        next = p == NULL ? NULL : p->next;
    }
    return head
}
```


```
ListNode* swapPairs(ListNode* head) {
    ListNode dummy;  // 虚拟头结点 dummy，方便处理头部交换。dummy 会保证链表入口始终正确。
    dummy->next = head;  // dummy.next 指向的是真正的头
    ListNode* p = dummy;   // p 指向 dummy 这个假头节点

    while (p->next && p->next->next) {
        ListNode* a = p->next;
        ListNode* b = p->next->next;

        // 交换 a 和 b
        a->next = b->next;
        b->next = a;
        p->next = b;

        // 移动 p
        p = a;
    }
    return dummy.next;
}

```

## 删除链表倒数第N个结点

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]

示例 2：

输入：head = [1], n = 1 输出：[]

示例 3：

输入：head = [1,2], n = 1 输出：[1]

进阶：你能尝试使用一趟扫描实现吗？

思路1：第一趟遍历得到链表总长度k，第二趟遍历第k-n个结点处删除下一个结点即可
时间： O(n)
空间： O(1)
遍历趟数：2


卡点：边界情况怎么统一处理？

思路2：双指针的经典应用。
如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。
1.首先这里我推荐大家使用虚拟头结点，这样方便处理删除实际头结点的逻辑。
2.定义fast指针和slow指针，初始值为虚拟头结点。
3.fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点。
5.fast和slow同时移动，直到fast指向末尾(末尾不是最后一个结点，而是最一个结点的next,即NULL)。
6.删除slow指向的下一个节点

输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]

输入：head = [1], n = 1 输出：[]

输入：head = [1,2], n = 1 输出：[1]

```
ListNode* removeNthFromEnd(ListNode* head, int n) {
    // 带头结点（dummy）
    ListNode dummy;
    dummy->next = head;

    ListNode* fast = dummy;
    ListNode* slow = dummy;

    // fast 先走 n+1 步
    for (int i = 0; i <= n; i++) {
        if (fast) fast = fast->next;
    }

    // fast 和 slow 一起走，直到 fast 到达末尾
    while (fast) {
        fast = fast->next;
        slow = slow->next;
    }

    // 删除 slow->next
    ListNode* del = slow->next;
    if (del) {
        slow->next = del->next;
        free(del);
    }

    return dummy.next; // 返回新的头结点
}
```

## 链表相交
给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

题目数据 保证 整个链式结构中不存在环。
注意，函数返回结果后，链表必须 保持其原始结构 。

思路： 这和字符串的模式匹配逻辑相同，暴力匹配。
时间： O(n^2)
空间： O(1)



思路2: 思路1错误, 这里求的是指针相同的情况下的交点, 而不是求相同的数值。
因为题中要求不改变原链表结构。 所以双指针法（浪漫相遇法）不可以使用。

我们求出两个链表的长度，并求出两个链表长度的差值，然后让curA移动到，和curB 末尾对齐的位置。
此时我们就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。
否则循环退出返回空指针。


```
ListNode* getIntersectionNode(ListNode *headA, ListNode *headB) {
    ListNode* curA = headA;
    ListNode* curB = headB;
    int lenA = 0, lenB = 0;
    while (curA != NULL) { // 求链表A的长度
        lenA++;
        curA = curA->next;
    }
    while (curB != NULL) { // 求链表B的长度
        lenB++;
        curB = curB->next;
    }
    curA = headA;
    curB = headB;
    // 让curA为最长链表的头，lenA为其长度
    if (lenB > lenA) {
        swap (lenA, lenB);
        swap (curA, curB);
    }
    // 求长度差
    int gap = lenA - lenB;
    // 让curA和curB在同一起点上（末尾位置对齐）
    while (gap--) {
        curA = curA->next;
    }
    // 遍历curA 和 curB，遇到相同则直接返回
    while (curA != NULL) {
        if (curA == curB) {
            return curA;
        }
        curA = curA->next;
        curB = curB->next;
    }
    return NULL;
}
};
```


## 环形链表

题意： 给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。
说明：不允许修改给定的链表。
![题目2](https://file1.kamacoder.com/i/algo/20200816110112704.png)

思路1： 设置一个集合。遍历过程中加结点放入集合，若集合中已存在该结点，则表示有环，返回该结点。
时间： O(n)
空间： O(n)


思路2：双指针
这道题目，不仅考察对链表的操作，而且还需要一些数学运算。
主要考察两知识点：
1.判断链表是否环
2.如果有环，如何找到这个环的入口
对于1，分别定义 fast 和 slow 指针，从头结点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。
      这是因为fast是走两步，slow是走一步，其实相对于slow来说，fast是一个节点一个节点的靠近slow的，所以fast一定可以和slow重合。
对于2，证明过程很多，详细见[证明](https://resprogrammercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF)

时间： O(n)
空间： O(1)

```
ListNode *detectCycle(ListNode *head) {
    ListNode *fast = head, *slow = head;
    while (fast && fast->next) {
        // 这里判断两个指针是否相等，所以移位操作放在前面
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) { // 相交，开始找环形入口：分别从头部和从交点出发，找到相遇的点就是环形入口
            ListNode *f = fast, *h = head;
            while (f != h) f = f->next, h = h->next;
            return h;
        }
    }
    return NULL;
}
```


## 三数之和
给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
注意： 答案中不可以包含重复的三元组。

示例：
给定数组 nums = [-1, 0, 1, 2, -1, -4]，
满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]

思路1: 3层遍历，保存i+j+z=0的变量值。
时间： O(n^3)
空间： O(1)

思路2:
首先将数组排序，然后有一层for循环，i从下标0的地方开始，同时定一个下标left 定义在i+1的位置上，定义下标right 在数组结尾的位置上。
如何移动left 和right呢， 如果nums[i] + nums[left] + nums[right] > 0 就说明 此时三数之和大了，因为数组是排序后了，所以right下标就应该向左移动，这样才能让三数之和小一些。
如果 nums[i] + nums[left] + nums[right] < 0 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到left与right相遇为止。
时间： O(n^2)
空间： O(1)

```
//qsort辅助cmp函数
int cmp(const void* ptr1, const void* ptr2) {
    return *((int*)ptr1) > *((int*)ptr2);
}

int** threeSum(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    //开辟ans数组空间
    int **ans = (int**)malloc(sizeof(int*) * 18000);
    int ansTop = 0;
    //若传入nums数组大小小于3，则需要返回数组大小为0
    if(numsSize < 3) {
        *returnSize = 0;
        return ans;
    }
    //对nums数组进行排序
    qsort(nums, numsSize, sizeof(int), cmp);


    int i;
    //用for循环遍历数组，结束条件为i < numsSize - 2(因为要预留左右指针的位置)
    for(i = 0; i < numsSize - 2; i++) {
        //若当前i指向元素>0，则代表left和right以及i的和大于0。直接break
        if(nums[i] > 0)
            break;
        //去重：i > 0 && nums[i] == nums[i-1]
        if(i > 0 && nums[i] == nums[i-1])
            continue;
        //定义左指针和右指针
        int left = i + 1;
        int right = numsSize - 1;
        //当右指针比左指针大时进行循环
        while(right > left) {
            //求出三数之和
            int sum = nums[right] + nums[left] + nums[i];
            //若和小于0，则左指针+1（因为左指针右边的数比当前所指元素大）
            if(sum < 0)
                left++;
            //若和大于0，则将右指针-1
            else if(sum > 0)
                right--;
            //若和等于0
            else {
                //开辟一个大小为3的数组空间，存入nums[i], nums[left]和nums[right]
                int* arr = (int*)malloc(sizeof(int) * 3);
                arr[0] = nums[i];
                arr[1] = nums[left];
                arr[2] = nums[right];
                //将开辟数组存入ans中
                ans[ansTop++] = arr;
                //去重
                while(right > left && nums[right] == nums[right - 1])
                    right--;
                while(left < right && nums[left] == nums[left + 1])
                    left++;
                //更新左右指针
                left++;
                right--;
            }
        }
    }

    //设定返回的数组大小
    *returnSize = ansTop;
    *returnColumnSizes = (int*)malloc(sizeof(int) * ansTop);
    int z;
    for(z = 0; z < ansTop; z++) {
        (*returnColumnSizes)[z] = 3;
    }
    return ans;
}
```


