# 文件系统：

超级块 inode表位图 数据区位图 inode表 数据区

# inode节点：

1.保存的是文件的原数据。

2.文件系统中inode节点数量 = 文件系统拥有的最大文件数量

它是如何引用数据块的位置？

1.在inode中有一个或多个直接指针（磁盘地址）​。每个指针指向属于该文件的一个磁盘块。

`局限`：如果你想要一个非常大的文件（例如，大于块的大小乘以直接指针数）​，那就不走运了。

2.多级索引。inode可以有一些固定数量（例如 12个）的直接指针和一个间接指针，间接指针它不是指向包含用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据。

如果文件变得足够大，则会分配一个间接块（来自磁盘的数据块区域）​，并将inode的间接指针设置为指向它。假设一个块是4KB，磁盘地址是4字节，那就增加了1024个指针。文件可以增长到（12 + 1024）×4KB，即4144KB。

你可能希望支持更大的文件。为此，只需添加另一个指向inode的指针：双重间接指针​。`该指针指的是一个包含间接块指针的块`，每个间接块都包含指向数据块的指针。因此，双重间接块提供了可能性，允许使用额外的1024×1024个4KB块来增长文件，换言之，支持超过4GB大小的文件。不过，你可能想要更多，我们打赌你知道怎么办：三重间接指针



 # 目录
 每个目录有两个额外的条目：.（点）和..（点点）​。点目录就是当前目录​，而点点是父目录​。
 目录只是“存储名称→inode号”映射的特定类型的文件

 文件系统将目录视为特殊类型的文件。因此，目录有一个inode，位于inode表中的某处（inode表中的inode标记为“目录”的类型字段，而不是“常规文件”​）​。该目录具有由inode指向的数据块（也可能是间接块）​。这些数据块存在于我们的简单文件系统的数据块区域中。我们的磁盘结构因此保持不变。

# 空闲空间管理
 当我们创建一个文件时，我们必须为该文件分配一个inode。所以文件系统必须记录哪些inode和数据块是空闲的，哪些不是，这样在分配新文件或目录时，就可以为它找到空间。因此，空闲空间管理（free space management）对于所有文件系统都很重要
 1.位图
 2.空闲列表​，其中超级块中的单个指针保持指向第一个空闲块。在该块内部保留下一个空闲指针，从而通过系统的空闲块形成列表。在需要块时，使用头块并相应地更新列表。


 # 访问路径：读取和写入
 理解这个访问路径（access path）上发生的事情，是开发人员理解文件系统如何工作的第二个关键

 open()的最后一步是将bar的inode读入内存。然后文件系统进行最后的权限检查，在每个进程的打开文件表中，为此进程分配一个文件描述符，并将它返回给用户。注意，open()函数只是读入了inode,还未开始读取真正的数据块。读取数据块是当你使用read()系统调用。

 打开导致了多次读取，以便最终找到文件的inode。另外请注意，open导致的I/O量与路径名的长度成正比。对于路径中的每个增加的目录，我们都必须读取它的inode及其数据。更糟糕的是，会出现大型目录。在这里，我们只需要读取一个块来获取目录的内容，而对于大型目录，我们可能需要读取很多数据块才能找到所需的条目。是的，读取文件时生活会变得非常糟糕。你会发现，写入一个文件（尤其是创建一个新文件）更糟糕。


 写入文件在逻辑上会导致5个I/O：一个读取数据位图（然后更新以标记新分配的块被使用）​，一个写入位图（将它的新状态存入磁盘）​，再有两次I/O，其中一次是读取inode，另一次是写inode（为了更新块的位置）​，最后一次写入真正的数据块本身。

 考虑简单和常见的操作（例如文件创建）​，写入的工作量更大。如下：
 要创建一个文件，文件系统不仅要分配一个inode，还要在包含新文件的目录中分配空间。这样做的I/O工作总量非常大：一个读取inode位图（查找空闲inode）​，一个写入inode位图（将其标记为已分配）​，一个写入新的inode本身（初始化它）​，一个写入目录的数据（将文件的高级名称链接到它的inode号）​，以及一个读写目录inode以便更新它。如果目录需要增长以容纳新条目，则还需要额外的I/O（即数据位图和新目录块）​。所有这些只是为了创建一个文件！

`关键问题`：如何降低文件系统I/O成本
 即使是最简单的操作，如打开、读取或写入文件，也会产生大量I/O操作，分散在磁盘上。文件系统可以做些什么，来降低执行如此多I/O的高成本？
 1.大多数文件系统积极使用系统内存（DRAM）来缓存重要的块。
 想象一下上面的打开示例：没有缓存，每个打开的文件都需要对目录层次结构中的每个级别至少进行两次读取（一次读取相关目录的inode，并且至少有一次读取其数据）​。使用长路径名（例如，/1/2/3/…/100/file.txt）​，文件系统只是为了打开文件，就要执行数百次读取！
 1.1 静态划分：固定大小缓存，这个固定大小的缓存通常会在启动时分配，大约占总内存的10%。
 1.2 动态划分：将虚拟内存页面和文件系统页面集成到统一页面缓存中。可以在虚拟内存和文件系统之间更灵活地分配内存，具体取决于在给定时间哪种内存需要更多的内存。
 写缓冲肯定有许多优点。
 首先，通过延迟写入，文件系统可以将一些更新编成一批（batch）​，放入一组较小的I/O中。例如，如果在创建一个文件时，inode位图被更新，稍后在创建另一个文件时又被更新，则文件系统会在第一次更新后延迟写入，从而节省一次I/O。
 其次，通过将一些写入缓冲在内存中，系统可以调度（schedule）后续的I/O，从而提高性能。
 最后，一些写入可以通过拖延来完全避免

 像通常一样，没有最好的方法。你应该考虑手头的问题，并确定哪种方法最适合。实际上，你不是应该一直这样做吗？

 由于上述原因，大多数现代文件系统将写入在内存中缓冲5～30s，这代表了另一种折中：如果系统在更新传递到磁盘之前崩溃，更新就会丢失。但是，将内存写入时间延长，则可以通过批处理、调度甚至避免写入，提高性能。
 某些应用程序（如数据库）不喜欢这种折中。因此，为了避免由于写入缓冲导致的意外数据丢失，它们就强制写入磁盘，通过调用fsync()，使用绕过缓存的直接I/O（direct I/O）接口，或者使用原始磁盘（raw disk）接口并完全避免使用文件系统



 # 设备管理
I/O设备依赖机械运动，而CPU计算是纯电子开关，它的计算速度要比I/O操作高几个数量级。


I/O系统：
设备管理器 => 包含大量设备驱动程序 ==> 了解设备控制器接口

设备管理器由一个设备无关部分和大量的与设备相关的设备驱动程序程序组成



# 编译时 和 运行时 的区别

1. 编译时 (compile time)

👉 程序还没执行，只是被编译器翻译成机器码的阶段。

- 特征：
    - 编译器要知道变量的类型、内存大小。
    - 数组长度必须是常量（除非编译器支持 VLA）。
    - 错误（语法错误、类型错误）会在编译时报出来。

例子：
```
#include <stdio.h>

int main() {
    int n = 10;
    int arr[10];      // ✅ OK，大小是常量，编译时就能确定
    // int arr[n];    // ❌ 在 C89 里不允许，编译报错 (n 不是编译时常量)

    printf("Array size: %zu\n", sizeof(arr)); // 已经固定为 40 (10*4)
    return 0;
}

```


2. 运行时 (run time)

👉 程序开始执行以后，根据用户输入/环境/逻辑，才决定变量大小、内存分配。

- 特征：
    - 数组大小不一定事先知道。
    - 可以用 malloc/calloc/realloc 在运行时申请内存。
    - 错误（除零、数组越界、空指针访问）要在运行时报。

🔹 例子：
```
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n;
    printf("请输入数组大小: ");
    scanf("%d", &n);

    int* arr = (int*)malloc(n * sizeof(int)); // ✅ 在运行时才决定大小
    for (int i = 0; i < n; i++) {
        arr[i] = i;
    }

    printf("arr[0] = %d, arr[%d] = %d\n", arr[0], n-1, arr[n-1]);
    free(arr); // 运行时申请的必须运行时释放
    return 0;
}

```
这里 arr 的大小只有用户输入以后才能确定，所以必须 运行时动态分配。

3. 直观类比
- 编译时 = 盖房子前，设计图纸：尺寸、材料都必须确定。

- 运行时 = 房子建好后，实际使用：住几个人、家具怎么摆，执行时才决定。


✅ 总结：

- 编译时：代码还没跑，编译器必须确定的部分（语法、类型、常量大小）。

- 运行时：程序运行过程中才确定的部分（用户输入、动态内存、分支逻辑）。

# 为什么sizeof(int)为4，而sizeof(int*)为8？
在大多数现代平台（比如 64 位 Linux/Windows，GCC/Clang/MSVC 编译器），int 的大小是 4 字节。

int* 是 指针，它存储的是一个 地址，指向某个 int 类型的变量。指针的大小取决于 CPU 的寻址能力，而不是指向的数据类型。
在 64 位系统中：
内存地址是 64 位（8 字节）。
所以不管是 int*、char*、double*，它们的大小都是 8。