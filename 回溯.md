#  二叉树的所有路径
给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。
示例：
![示例](https://file1.kamacoder.com/i/algo/2021020415161576.png)

## 思路
这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。
在这道题目中将涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。

前序遍历以及回溯的过程如图：
![过程](https://file1.kamacoder.com/i/algo/20210204151702443.png)
我们先使用递归的方式，来做前序遍历。 递归和回溯是对称的，在递归后，就需紧跟着回溯。
回溯的写法分为显示回溯和隐式回溯。显示回溯又分为父节点负责回溯和自我负责制。


## 显示回溯-自我负责制：
### 什么是“显式”回溯？
如果我们为了节省内存，不使用字符串副本，而是使用一个 列表 (List) 来记录路径，那么就必须进行“显式回溯”。因为列表是可变对象，所有递归层级都共享同一个列表。
下面第一版递归代码中，把递归与回溯的细节都充分的展现了出来
```python
def binary_tree_paths(root):
    res = []
    path = []  # 共享的列表
    
    if not root:
        return res
    
    def backtrack(node):
        if not node:
            return
        
        path.append(str(node.val))
        
        # 判断是否到达了叶子节点
        if not node.left and not node.right:
            res.append("->".join(path))
        else:
            if node.left: backtrack(node.left)
            if node.right: backtrack(node.right)
        # 回溯
        path.pop() 

    backtrack(root)
    return res
```



## 隐士回溯：

```python
def binary_tree_paths(root):
    # 结果列表，用来存放所有路径
    paths = []
    
    if not root:
        return paths

    def construct_paths(node, current_path):
        if not node:
            return
        
        current_path += str(node.val)
        
        # 判断是否到达了叶子节点
        if not node.left and not node.right:
            paths.append(current_path)
        else:
            # 如果不是叶子节点，说明还得继续往下走
            # 既然要继续走，就在路径后面加上 "->"
            current_path += "->" 
            
            if node.left:
                construct_paths(node.left, current_path)
            if node.right:
                construct_paths(node.right, current_path)

    construct_paths(root, "")
    return paths
```
为什么说是“隐式”的？
在代码中，我们使用的是 字符串拼接： construct_paths(node.left, current_path + "->")

在 Python 中，字符串是不可变对象。当你把 current_path + "->" 传给下一层函数时，实际上是创建了一个全新的字符串副本。

当左子树的递归结束并返回到当前层时，当前层的 current_path 变量依然保持着它进入左子树之前的样子。

这种依靠函数调用栈自动恢复状态的行为，我们称之为“隐式回溯”。




## 显示回溯-父节点负责制：
第三版是父节点负责回溯

```python
def binary_tree_paths(root):
    res = []
    path = []
    if not root:
        return res
    
    def traversal(node):
        if not node:
            return
        
        path.append(str(node.val))

        # 判断是否到达了叶子节点
        if not node.left and not node.right:
            res.append("->".join(path))
            return
        if node.left: 
            traversal(node.left)
            path.pop() 
        if node.right: 
            traversal(node.right)
            path.pop() 
    traversal(root, path, res)
    return res
```

在这一版代码逻辑中，path.append(node.val) 是在进入函数的第一步执行的。而 path.pop() 紧跟在递归调用之后。

这意味着：
- 当前节点（孩子） 负责把自己的值加进去。
- 父节点 负责在递归调用结束（孩子返回）后，把刚才那个孩子加进去的值“踢出去”。


通常教科书上的“标准回溯”写法是“自我负责制”

总结：回溯的本质就是：走不通了或者走完了，就往后退一步，回到原来的状态，再去试别的路。
根据编程语言的特性：
- 传入的是可变对象的引用时（比如列表），一般需要显示的pop；
- 传入的是不可变对象的引用时（比如字符串/数字），一般依靠函数调用栈自动恢复状态，无需显示实现回溯

