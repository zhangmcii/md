1. 索引（B+Tree）原理与优化
2. SQL 性能优化（Explain）
3. 事务与隔离级别（ACID）
4. 锁机制（行锁/表锁/间隙锁）
5. InnoDB 与 MyISAM 区别
6. 索引失效场景
7. 覆盖索引、联合索引最佳实践
8. MVCC（多版本并发控制）
9. 慢查询分析（Slow Query Log）
10. 分库分表与水平扩展


## （简单）为什么 MySQL 使用 B+Tree 作为索引结构，而不是使用哈希表或二叉搜索树？
## B+Tree 索引在查询时是如何工作的？为什么 B+Tree 适合范围查询？
## （困难）在什么情况下索引会失效？请列举至少 3 种常见导致索引失效的 SQL 写法，并解释原因。


解答1:
（1）普通二叉搜索树由于无法保证平衡，最坏情况下会退化成链表，查询复杂度变成 O(n)，并且每个节点只有两个子节点，树会很高，导致磁盘 IO 次数多，因此不适合数据库。[先讲 BST 为什么不行（对比是加分项）]

（2）B-Tree 是多路平衡树，一个节点可以存储多个 key，大幅减少树高度；所有数据可能存在所有节点，提高了插入、删除性能。[再讲 B-Tree 解决什么问题]

（3）MySQL InnoDB 采用 B+Tree，是因为它进一步优化了存储结构：               [最后讲 B+Tree 的优势（核心重点）,必须包含 3 点：]
    3.1 非叶子节点只存索引，叶子节点存数据，因此节点更小、阶数更高、树更矮，磁盘 IO 最少； 
    3.2 同时叶子节点通过链表顺序连接，范围查询特别高效。
    3.3 并且 InnoDB 的主键索引是聚簇索引，叶子节点存整行数据，辅助索引存主键，支持高效查询。


解答2:
InnoDB 的主键索引是聚簇索引，叶子节点直接存储整行数据，因此主键查询只需一次 B+Tree 查找。        [先解释 InnoDB 的两种索引结构]
而普通索引是非聚簇索引，它的叶子节点只包含索引列+主键值，
因此查询时必须先通过二级索引定位主键，再回到聚簇索引取整行，这一步称为“回表”。              [给出二级索引查询流程（重点）]
另外，B+Tree 叶子节点天然按顺序链表连接，因此范围查询非常高效。


解答3:
索引失效主要因为 MySQL 不能利用 B+Tree 的有序性。
最常见三类：① 对索引列做函数/运算；② 联合索引违反最左前缀；③ LIKE '%xxx' 前缀不确定。
另外隐式转换、OR 条件、不等号也常导致无法走索引。
