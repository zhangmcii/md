1. 索引（B+Tree）原理与优化
2. SQL 性能优化（Explain）
3. 事务与隔离级别（ACID）
4. 锁机制（行锁/表锁/间隙锁）
5. InnoDB 与 MyISAM 区别
6. 索引失效场景
7. 覆盖索引、联合索引最佳实践
8. MVCC（多版本并发控制）
9. 慢查询分析（Slow Query Log）
10. 分库分表与水平扩展


## （简单）为什么 MySQL 使用 B+Tree 作为索引结构，而不是使用哈希表或二叉搜索树？
## B+Tree 索引在查询时是如何工作的？为什么 B+Tree 适合范围查询？
## （困难）在什么情况下索引会失效？请列举至少 3 种常见导致索引失效的 SQL 写法，并解释原因。


解答1:
（1）普通二叉搜索树由于无法保证平衡，最坏情况下会退化成链表，查询复杂度变成 O(n)，并且每个节点只有两个子节点，树会很高，导致磁盘 IO 次数多，因此不适合数据库。[先讲 BST 为什么不行（对比是加分项）]

（2）B-Tree 是多路平衡树，一个节点可以存储多个 key，大幅减少树高度；所有数据可能存在所有节点，提高了插入、删除性能。[再讲 B-Tree 解决什么问题]

（3）MySQL InnoDB 采用 B+Tree，是因为它进一步优化了存储结构：               [最后讲 B+Tree 的优势（核心重点）,必须包含 3 点：]
    3.1 非叶子节点只存索引，叶子节点存数据，因此节点更小、阶数更高、树更矮，磁盘 IO 最少； 
    3.2 同时叶子节点通过链表顺序连接，范围查询特别高效。
    3.3 并且 InnoDB 的主键索引是聚簇索引，叶子节点存整行数据，辅助索引存主键，支持高效查询。


解答2:
InnoDB 的主键索引是聚簇索引，叶子节点直接存储整行数据，因此主键查询只需一次 B+Tree 查找。        [先解释 InnoDB 的两种索引结构]
而普通索引是非聚簇索引，它的叶子节点只包含索引列+主键值，
因此查询时必须先通过二级索引定位主键，再回到聚簇索引取整行，这一步称为“回表”。              [给出二级索引查询流程（重点）]
另外，B+Tree 叶子节点天然按顺序链表连接，因此范围查询非常高效。


解答3:
索引失效主要因为 MySQL 不能利用 B+Tree 的有序性。
**最常见三类**：① 对索引列做函数或计算；② 联合索引违反最左前缀；③ LIKE '%xxx' 前缀不确定。
另外隐式转换、OR 条件、不等号也常导致无法走索引。

最常见的三类：
```aiignore
SELECT * FROM user WHERE LEFT(name, 3) = 'Tom';  [函数]
SELECT * FROM order WHERE amount + 1 = 100;     [计算]
SELECT * FROM user WHERE DATE(create_time) = '2024-01-01';   [函数]


# 联合索引：(a, b, c)
WHERE b = 1;           -- 未使用 a
WHERE c = 1;           -- 未使用 a,b
WHERE b = 1 AND c = 2; -- 跳过最左

# 模糊匹配以 % 开头
WHERE name LIKE '%abc';   -- 前缀模糊

# 可以使用索引
WHERE name LIKE 'abc%';


```

额外：
```
# 隐式转换
WHERE phone = 13800138000;   -- phone 是 varchar
因为 MySQL 会：CAST(phone AS int) → 效果等同函数 → 失效。

# OR 两侧只要有一个列没有索引，也会导致整体不走索引
WHERE name = 'Tom' OR age = 20;
除非两个字段都有索引。 [因为 OR 需要“并集”两个查询结果。如果其中一条需要全表扫描，为了组合结果 必须扫描整张表，那扫描一整次就够了，没必要再单独为另一侧走索引。]

# 使用 !=、<>、NOT IN、NOT LIKE 常导致无法走索引
WHERE age <> 18;
WHERE name NOT LIKE 'Tom%';
因为无法使用 B+Tree 的区间查找。[因为最终需要扫描绝大部分索引记录，几乎等同全表扫描.MySQL 优化器因此可能放弃索引。除非该值极端稀少，否则一般不会走索引。]
```


> 联合索引: 是按顺序把多个字段组合成一个 B+Tree，遵守最左前缀原则；
           多条件查询更快，因为能在更小范围内继续有序查找；
           范围查询会导致后续列失效。



## (基础)为什么使用 SELECT * 会影响 SQL 性能？应该用什么替代？
## 慢查询出现时，你如何定位问题？请简述完整的排查步骤。 (提示：你可以从 执行计划 / 索引 / SQL 写法 / 表结构 / 数据量 等方面思考)
## (困难)请解释什么是 “覆盖索引（Covering Index）”，它是如何提升查询性能的？并举一个示例 SQL。

解答1：
因为select * 会返回所有的字段。 用需要返回的字段代替*
评分：4 / 10 。 没有体现面试官想听到的关键点，例如： 为什么返回所有字段会变慢？（IO？网络？覆盖索引？无法使用索引？）


SELECT * 影响性能，主要原因有：
1）读取不必要字段 → 增加磁盘 IO 和 CPU 开销
服务器必须扫描并返回全部字段，即使你只用其中两个字段。

2）占用更多网络带宽
字段越多、数据越宽，每次查询返回的包越大，延迟更高。

3）导致无法使用“覆盖索引”，从而必须回表（Extra: Using where; Using index 变成 Using where）
覆盖索引：查询所需字段全部在索引中即可避免回表。
但 SELECT * 一定需要读取整行 → 一定回表 → 性能降低。

4）降低可维护性与安全性
新增字段会自动被查询到，可能带来数据泄露风险。
业务代码依赖 *，导致 schema 改动风险（字段变更会破坏接口兼容性）。

替代方法 ：明确列出需要的字段，如 SELECT id, name FROM user。

解答2:
慢查询出现时，先通过sql执行耗时定位到具体的sql语句，
优化sql的查询字段，根据筛选条件和sql执行频率决定是否对字段添加索引
得分：4 / 10 。步骤缺失严重。慢查询排查通常至少包含 5 步，你只提到“定位 SQL”和“加索引”。

1. 定位慢查询来源
通过 慢查询日志（slow-query-log） 或监控平台定位 SQL。
SHOW PROCESSLIST 看正在执行的慢 SQL。

2. 使用 EXPLAIN 分析执行计划
是否走索引？
是否出现 type = ALL（全表扫描）？
索引是否选择错误？
是否出现 Using filesort / Using temporary？

3. 检查 SQL 写法是否导致索引失效
例如：
函数、计算、隐式转换
LIKE '%xxx'
OR 两侧字段索引不全
!=、<> 等不等值
范围查询阻断联合索引

4. 检查表结构 / 索引设计
索引是否遗漏？
索引顺序是否符合最左匹配原则？
是否有冗余索引？

5. 数据量 & 统计信息
analyze table 更新统计信息
是否需要分库分表
是否被锁住导致执行变慢

6. 优化方向总结
优化 SQL → 调整索引 → 调整表结构 → 缓存 → 拆分

解答3:
SELECT * 影响性能，因为会增加 I/O、网络开销，且无法使用覆盖索引。实际开发应只查需要的字段。
遇到慢 SQL 时，从慢日志找到具体语句，然后通过 EXPLAIN 分析是否走索引、是否全表扫描、是否出现临时表/排序，再检查 SQL 写法、索引设计、字段类型与数据量，最终通过优化 SQL 或调整索引来解决。
覆盖索引指查询所需字段都在索引中，可以避免回表，减少磁盘 I/O，大幅提升性能。例如建立 (name, age) 索引后，查询 SELECT name, age… 可以直接在索引中完成。


覆盖索引指： 查询所需要的字段全部在索引中即可得到，而不需要回表访问数据页。
② 为什么快？（核心原因）
1.避免回表（最重要）
不需要从二级索引根据主键再去查聚簇索引，大幅减少随机 I/O。

2.索引更小、更适合放入内存
索引页远小于数据页，命中率更高。

3.减少磁盘 I/O + CPU 消耗
只扫描索引，通常是顺序 I/O。

例如建立 (name, age) 索引后，查询 SELECT name, age… 可以直接在索引中完成。


## （基础）请解释事务的 ACID 四大特性，并分别举一个例子说明。
## 请你分别解释 MySQL 四种隔离级别，并说说在默认隔离级别下（InnoDB），脏读/不可重复读/幻读是否会发生？
## （困难）InnoDB 是如何通过 MVCC 来避免不可重复读的？请结合 undo log 说明快照读是怎么工作的。

解答1:
ACID 包含四个特性：原子性、 一致性、隔离性、持久性。
1.原子性（Atomicity） ：
事务内的操作要么全部成功，要么全部失败，不会出现部分执行。

2.一致性（Consistency）
事务前后数据必须满足业务规则与约束，整体状态保持一致。例如转账后 A+B 的总金额不变。

3.隔离性（Isolation）
并发事务之间彼此隔离，一个事务的中间结果对其他事务不可见，从而避免互相影响。

4.持久性（Durability）
事务提交后，对数据的修改会被永久保存，即使宕机也不会丢失。

一句话总结：
ACID 保证事务执行“要么全做、数据正确、互不干扰、落盘可靠”，从而确保数据库在并发与异常情况下依然保持一致、可依赖。


解答2:
MySQL 有 4 种隔离级别，从低到高：读未提交、读已提交、可重复读、串行化。
1）读未提交
* 能读到其他事务 未提交 的数据
* 会出现：脏读、不可重复读、幻读（最弱）
2）读已提交
* 只能读到“已提交”数据
* 解决：脏读
* 仍会发生：不可重复读、幻读（Oracle 默认级别）
3）可重复读   （`MySQL 默认`）
* 一个事务里多次读取同一行，结果保持一致
* 解决：脏读、不可重复读
* MySQL 的 InnoDB 通过 MVCC + Next-Key Lock 避免大部分幻读问题
4）串行化
* 所有事务串行执行
* 完全避免：脏读 / 不可重复读 / 幻读
* 效率最差（加大量锁）

在事务并发操作时，可能出现的问题有：脏读 / 不可重复读 / 幻读
然而事务的不同的隔离级别会逐步解决上述问题
> 脏读：读到了别的事务 尚未提交的更新，这些数据可能会回滚
  不可重复读：前后两次读取到 同一行数据不一致（别人提交了更新）。    【强调的是“记录被改了”】 
  幻读：在同一事务中，前后两次读取 符合条件的行数不一致（别人插入或删除了新行）。  【强调“凭空多/少了记录”】


事务、并发读问题、隔离级别 **逻辑链**:
事务提供并发控制能力，而并发会产生脏读、不可重复读、幻读三类问题； 
"隔离级别"就是为了解决这些问题，不同隔离级别牺牲不同程度的性能来换取更强的隔离性。

解答3:
InnoDB 通过 MVCC（多版本并发控制） 来避免“不可重复读”。核心思想是：
读操作不直接读最新数据，而是读 undo log 生成的“历史版本快照”。
因此，即使别的事务已更新或提交，你在当前事务里看到的仍然是 开启事务时的一致视图。



额外：
EXPLAIN = SQL 在数据库中的实际执行策略，不看它就是盲写 SQL。
EXPLAIN 是优化器对 SQL 的“决策过程”可视化。

EXPLAIN 的核心目标就是：
①判断 SQL 是否正确使用了索引，并确认扫描行数是否合理。（看 type、key、rows、Extra）
② 最重要的四个指标：
type：访问方式（ALL > index > range > ref > eq_ref > const），越靠前越好 
key：是否命中索引
rows：扫描越少越快
Extra：是否 Using temporary / Using filesort（性能杀手）


一句话总结：
EXPLAIN 不告诉你“SQL 执行花了多久”，它告诉你“为什么会慢”。



## 什么是行锁和表锁？MySQL 中哪些存储引擎支持行锁？
## InnoDB 的行锁是在“行”上加的吗？为什么说 InnoDB 的行锁是“基于索引”的？
## 什么是间隙锁（Gap Lock）？它解决了什么问题？在什么隔离级别下会生效？

解答1:
InnoDB实现标准的行级锁定，其中有两种类型的锁， 共享 ( S) 锁和独占 ( X) 锁。
共享锁允许持有锁的事务读取一行 。
独占锁允许持有锁的事务更新或删除行 

意向锁是表级锁，指示事务稍后对表中的行需要哪种类型的锁（共享或独占）
意向共享锁 表示事务打算在表中的各个行上设置 共享 锁 。
意向排他锁 IX表示事务打算在表中的各个行上设置 排他 锁。