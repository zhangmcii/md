# 一文看透“回溯”本质

在算法面试中，二叉树的题目千千万，但核心套路往往离不开“遍历”。今天我们要挑战的是：**给定一个二叉树，返回所有从根节点到叶子节点的路径。**

### 1. 核心思路：为什么要“回溯”？

想象你在走一个迷宫，每到一个分叉路口，你都会选一条路往下走。当你走到死胡同（叶子节点）时，你会怎么办？你肯定得**往后退一步**，回到上一个路口，再试另一条路。

这种“走不通就回头”的操作，在算法里就叫 **回溯**。

* **遍历顺序**：我们要从根节点开始记录，显然适合用**前序遍历**（根-左-右）。
* **记录路径**：用一个列表 `path` 记录走过的节点。
* **关键点**：每当递归返回上一层时，我们要把刚才加进去的节点“弹出去”，否则它会干扰其他路径。

---

### 2. 写法一：显式回溯（手动挡）

这种写法最能体现算法精髓。我们使用一个 `list` 来维护路径。因为在 Python 中，列表是**可变对象**，所有递归层级都共享同一个列表，所以我们必须手动“擦除”痕迹。

#### 自我负责制：谁污染，谁治理

每一个节点负责把**自己**加进去，并在离开前把**自己**弹出来。

```python
def binary_tree_paths(root):
    res = []
    path = []
    
    if not root:
        return res
    
    def backtrack(node):
        # 1. 节点进站
        path.append(str(node.val))
        
        # 2. 终点判断：如果是叶子节点，记录结果
        if not node.left and not node.right:
            res.append("->".join(path))
        else:
            # 3. 继续向下探索
            if node.left: 
                backtrack(node.left)
            if node.right: 
                backtrack(node.right)
        
        # 4. 回溯：节点出站（离开前要把自己从路径中删掉）
        path.pop() 

    backtrack(root)
    return res

```

> **注意**：`path.pop()` 必须和 `path.append()` 成对出现。代码逻辑非常对称。

---

### 3. 写法二：隐式回溯（自动挡）

很多同学会发现，有时候代码里并没有写 `pop()`，路径也能正确记录。这是为什么？

因为他们使用了**字符串拼接**。在 Python 中，字符串是**不可变对象**。

```python
def binary_tree_paths(root):
    res = []
    if not root:
        return res

    def dfs(node, current_path):
        # 拼接当前节点
        current_path += str(node.val)
        
        if not node.left and not node.right:
            res.append(current_path)
            return
        
        # 如果还有子节点，带上 "->" 继续往下传
        if node.left:
            dfs(node.left, current_path + "->")
        if node.right:
            dfs(node.right, current_path + "->")

    dfs(root, "")
    return res

```

**原理揭秘**：
当你调用 `dfs(node.left, current_path + "->")` 时，Python 实际上创建了一个**新的字符串副本**传给了下一层。当左子树递归结束返回时，当前层的 `current_path` 还是原来的样子，这就完成了“自动回溯”。

---

### 4. 写法三：父节点负责制（严谨派）

在某些复杂的工业级代码里，你可能会看到这种写法：父节点负责把孩子节点带进去，也负责把它带出来。

```python
def binary_tree_paths(root):
    res = []
    if not root: return res
    
    # 根节点先入队
    path = [str(root.val)]

    def traversal(node):
        # 如果是叶子，直接结算
        if not node.left and not node.right:
            res.append("->".join(path))
            return
        
        # 父节点负责：推入子节点 -> 递归 -> 弹出子节点
        if node.left:
            path.append(str(node.left.val))
            traversal(node.left)
            path.pop() # 回溯
            
        if node.right:
            path.append(str(node.right.val))
            traversal(node.right)
            path.pop() # 回溯

    traversal(root)
    return res

```

这种写法逻辑非常清晰：**“我带你进去，我也得负责把你带出来。”** 这种对称性在处理更复杂的搜索问题（如迷宫寻路、N皇后）时非常管用。

---

### 💡 总结与建议

1. **传引用（List）**：必须**显式回溯**，用 `pop()` 手动恢复状态，省内存，效率高。
2. **传值（String）**：利用**隐式回溯**，靠函数调用栈自动恢复，代码简洁，但频繁创建字符串会消耗更多内存。

**建议**：初学者先练熟“显式回溯”，因为它是所有搜索算法（DFS/回溯）的通用模版

下一篇： [多叉树中的回溯](https://11.com)