既然我们上一篇已经拆解了二叉树的回溯精髓，今天我们就把难度稍微提一点点：**面对子节点数量不固定的“多叉树”，我们该如何记录从根节点到每个节点的属性累积和？**

这不仅是面试常客，在处理如“接口调用链耗时分析”或“文件目录大小统计”等后端实际场景中，也是非常实用的技能。

---

# 进阶：多叉树路径属性累加，依然是熟悉的回溯套路

在[一文看透“回溯”本质](https://11.com)中，我们学会了如何在二叉树中寻找路径。但在后端开发中，数据往往以**多叉树**的形式存在（比如权限树、组织架构）。

### 1. 场景还原：计算节点总耗时

**题目描述**：
给定一棵多叉树，每个节点都有一个 `runtime`（执行耗时）。请计算**每个节点到根节点**路径上的所有 `runtime` 之和。

### 2. 核心思路：状态的“向下传递”

这道题和上一篇找“叶子节点路径”有个微小的区别：

* **上一篇**：我们要找的是终点（叶子节点）的路径列表。
* **这一篇**：我们要记录的是**每一个**节点的状态。

**为什么它也叫回溯？**
虽然我们的代码里可能看不见 `pop()`，但我们利用了函数调用栈的特性，将当前路径的和 `current_sum` 传递给子节点。当子节点的递归函数执行完毕返回时，父层的 `current_sum` **依然保持原样**，这本质上就是一种**隐式回溯**。

---

### 3. 代码实现：清晰易懂的多叉树遍历

我们先定义节点结构，并使用 DFS（深度优先搜索）来完成任务。

```python
class Node:
    def __init__(self, name, runtime=0, children=None):
        self.name = name
        self.runtime = runtime
        self.children = children if children else []

def get_all_path_sums(root):
    # 用字典记录结果：{节点名: 路径总和}
    result = {}

    def traverse(node, current_sum):
        if not node:
            return
        
        # 1. 累加当前节点的属性值
        current_sum += node.runtime
        
        # 2. 记录当前节点的结果
        result[node.name] = current_sum

        # 3. 递归处理所有子节点
        # 与二叉树不同，这里通过 for 循环处理不确定数量的孩子
        for child in node.children:
            traverse(child, current_sum)
            # 注意：这里不需要手动减去 node.runtime，
            # 因为 current_sum 是按值传递的，下一层修改不会影响本层的变量

    traverse(root, 0)
    return result

```

---

### 4. 深度解析：为什么没有显式的回溯操作？

很多小白会问：“上一篇你说回溯要对称，这里怎么没看到‘减掉’的操作？”

这就是**显式回溯（列表）**与**隐式回溯（数值/字符串）**的区别：

1. **数值传递的特性**：在本代码中，`current_sum` 是一个整数。当你执行 `traverse(child, current_sum)` 时，Python 会把当前的数值**复制**一份传给子函数。
2. **自动恢复**：当子函数执行完返回后，父函数里的 `current_sum` 还是它原来的值。
3. **如果用列表呢？**：如果我们传入的是一个记录路径的 `list`，那么在 `for` 循环里，每处理完一个子节点，你就必须手动 `list.pop()`，否则下一个子节点就会看到上一个兄弟节点的路径。

**结论**：在处理“累加和”这类简单数值问题时，直接传值是最优雅、最不容易出错的选择。

---

### 5. 动手试试

你可以运行下面的测试代码，观察结果是否符合预期：

```python
if __name__ == '__main__':
    # 构建结构：root(3) -> a(3) -> a1(2), a2(2), a3(2)
    #               -> b(3) -> b1(1), b2(1), b3(5)
    a1, a2, a3 = Node('a1', 2), Node('a2', 2), Node('a3', 2)
    a = Node('a', 3, [a1, a2, a3])

    b1, b2, b3 = Node('b1', 1), Node('b2', 1), Node('b3', 5)
    b = Node('b', 3, [b1, b2, b3])

    root = Node('root', 3, [a, b])

    path_sums = get_all_path_sums(root)
    print(f"节点 a3 到根的耗时和: {path_sums['a3']}") # 应该是 3+3+2 = 8
    print(f"节点 b3 到根的耗时和: {path_sums['b3']}") # 应该是 3+3+5 = 11

```

### 💡 总结

多叉树的题目看起来唬人，但只要掌握了：

1. **数据结构转换**：把 `left/right` 变成 `for child in children`。
2. **状态传递**：明确哪些状态需要“向下带”（如路径和），哪些需要“向上传”（如子树节点总数）。

回溯思想就会像你的肌肉记忆一样自然。

