## TCP连接时，为什么需要第三次握手，而不是两次就可以了？
防止客户端和服务器建立因网络延迟问题建立多次连接。

如果把连接看成是一个实例，那么第三次握手，可以看成它是一个"单例模式"，确保在网络延迟的环境下，始终只建议一个tcp连接。



## TCP断开连接时，为什么需要四次挥手，而不是两次就可以了？ 最后客户端等待2MSL时间的原因是什么？
两次挥手后，客户端没有数据需要发送了，但服务器端可能还存在未传送完毕的数据，所以服务器端传送完毕后，服务器端会发送连接释放报文。

等待2MSL原因：
确保客户端发送的第4次挥手能够到达。如果服务端没收到客户端发送的确认报文，那么会重新发送连接释放请求，客户端等待一段时间后就是防止这种情况。

确保网络中本连接的残余报文全部消失，避免影响后续新的连接。



## 若等待 2 MSL 的时间，客户端重发了确认，但服务端依然没收到，这个连接会一直存在吗？

服务端会不断重发 FIN，直到 超过自己设置的超时/重传次数。客户端只要还在2 MSL内，就能处理这些 FIN 并回复 ACK。
如果最后一次 ACK 依然没到服务端，最终服务端会因为 超时 主动关闭连接。


## ACK 最多存活 1 MSL，那么2 MS内服务器最多能发2次？
不是说 2 MSL 内服务端最多只能发 2 次 FIN。 服务端能发多少次，取决于它的 RTO 设置和重传次数上限。

ACK 在网络里最多存活 1 MSL，TIME_WAIT 等 2 MSL 的目的不是限制服务端只能发 2 次 FIN，而是为了让所有可能的 FIN/ACK 报文在网络中完全消失。服务端实际能发几次 FIN，取决于它的重传策略和超时时间，而不是 MSL。


## 比如在服务端在1.5MSL时发送连接释放请求，而ACK 在网络里最多存活 1 MSL，那么等待该ACK失效，已经超过了2MSL，这和你说的客户端等待 2 MSL，只是保证无论如何，旧连接的报文都消失是否吗矛盾呢？

TIME_WAIT 的 2 MSL 是动态的，从最后一个 ACK 算起。
客户端每次发送 ACK，2 MSL 计时都需要重新开始。如果在 TIME_WAIT 期间又收到了 FIN，客户端会重发 ACK，并 刷新计时器。



## tcp的三次握手中，只有第三次客户端可携带数据，那么为什么第一次握手客户端要携带seq号？

客户端第一次握手虽然不能携带数据，但必须带上初始序列号 ISN，原因是：

- 建立序列号基准，让服务端知道后续数据应该从哪开始确认。

- 防止旧连接报文干扰，通过随机 ISN 区分新旧连接。

- 保证握手对称性，让服务端能在第二次握手中确认客户端的 ISN。


## 第一次握手客户端要携带seq号是为了建立序列号基准，那么第一次握手携带的字节数据是多少呢，是1字节？

结论：
- 第一次握手的 SYN 报文并不携带真实数据，数据部分为 0 字节；
- 但它会占用一个序列号，因此客户端的下一个有效序列号是 ISN+1。
- 这是 TCP 的规定：SYN 和 FIN 标志各自消耗一个序列号空间，即使不传数据。

解释：
在 TCP 中，SYN 和 FIN 标志位本身不携带数据，但会消耗一个序列号。

- SYN 消耗 1 序号

- FIN 消耗 1 序号

- ACK（无数据）不消耗序号

- 数据段消耗对应字节数的序号


## 第三次握手客户端可带数据，也可不带数据。如果不带数据，需要传递seq吗？

总结：
- 第三次握手 一定会带 seq，无论有没有数据。

- 如果不带数据，seq=x+1（SYN 占用的序号+1）。

- 如果带数据，从 x+1 开始编号，服务端根据 ack 确认。

解释：
无论是否携带数据，TCP 报文段的首部里一定有 Sequence Number（32 位，4 字节）字段。
所以 第三次握手一定会带 seq，这是 TCP 头部的标准部分，不是可选的。

如果第三次握手 不带数据

- 报文格式：ACK=1，seq=x+1，ack=y+1

- 其中 seq=x+1 的意思是：客户端上一次的 SYN 已经占用了一个序列号，现在下一个要使用的序号是 x+1。

- 虽然没有数据，但仍要显式传递 seq，这是 TCP 协议保证序号连续性的需要。


如果第三次握手 带数据

- 报文格式：ACK=1，seq=x+1，ack=y+1，payload=n bytes

- 这时数据会从 x+1 开始编号，最后一个字节编号是 x+n。

- 服务端收到后，就会 ack=x+1+n。



## 那么无论第三次是否携带数据，那么连接建立后，数据都从seq = x+2开始？

错误

结论： 三次握手后，应用层数据从 seq = x+1 开始，而不是 x+2。


解释： 
情况一：第三次握手不携带数据

1.第一次握手：客户端 → 服务端

- SYN=1, seq=x

- 消耗一个序号 → 下一个是 x+1

2.第二次握手：服务端 → 客户端

- SYN=1, ACK=1, seq=y, ack=x+1

- 服务端 ISN = y，消耗一个序号 → 下一个是 y+1

3.第三次握手：客户端 → 服务端

- ACK=1, seq=x+1, ack=y+1

- 这里没有数据，不额外消耗序号

所以，  连接建立后，客户端应用层第一个字节的数据就是 seq=x+1。


情况二：第三次握手携带数据

1.前两步同上。

2.第三次握手：客户端 → 服务端

- ACK=1, seq=x+1, ack=y+1, [data]

- 数据从 x+1 开始编号

- 如果携带 n 字节数据，那么占用的序号范围是 [x+1, x+n]

- 客户端下一个可用序号就是 x+1+n

所以，  所以应用层数据的起点依然是 x+1，只是这部分数据被“捎带”在第三次握手里了。

