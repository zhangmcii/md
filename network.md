## TCP连接时，为什么需要第三次握手，而不是两次就可以了？
防止客户端和服务器建立因网络延迟问题建立多次连接。

如果把连接看成是一个实例，那么第三次握手，可以看成它是一个"单例模式"，确保在网络延迟的环境下，始终只建立一个tcp连接。

如果两次握手就可以：
A发起连接请求，B的响应因网络延迟未能及时送达。A未收到B的确认，就会重新发送连接请求，B响应，这时AB之间建立了一条TCP连接。
过了一会，因网络延迟的响应到达A，AB之间建立起第二次连接。

三次握手：
B再次响应，A收到B的响应发出第三次握手，这时AB之间建立了一条TCP连接。后续因因网络延迟的响应到达A，


主要原因是为了防止旧的重复连接初始化造成混乱。

- 阻止重复历史连接的初始化
我们考虑一个场景，客户端先发送了 SYN（seq = 90）报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到，接着客户端重启后，
又重新向服务端建立连接，发送了 SYN（seq = 100）报文（注意！不是重传 SYN，重传的 SYN 的序列号是一样的）。



## TCP断开连接时，为什么需要四次挥手，而不是两次就可以了？ 最后客户端等待2MSL时间的原因是什么？
两次挥手后，客户端没有数据需要发送了，但服务器端可能还存在未传送完毕的数据，所以服务器端传送完毕后，服务器端会发送连接释放报文。

等待2MSL原因：
确保客户端发送的第4次挥手能够到达。如果服务端没收到客户端发送的确认报文，那么会重新发送连接释放请求，客户端等待一段时间后就是防止这种情况。

确保网络中本连接的残余报文全部消失，避免影响后续新的连接。



## 若等待 2 MSL 的时间，客户端重发了确认，但服务端依然没收到，这个连接会一直存在吗？

服务端会不断重发 FIN，直到 超过自己设置的超时/重传次数。客户端只要还在2 MSL内，就能处理这些 FIN 并回复 ACK。
如果最后一次 ACK 依然没到服务端，最终服务端会因为 超时 主动关闭连接。


## ACK 最多存活 1 MSL，那么2 MS内服务器最多能发2次？
不是说 2 MSL 内服务端最多只能发 2 次 FIN。 服务端能发多少次，取决于它的 RTO 设置和重传次数上限。

ACK 在网络里最多存活 1 MSL，TIME_WAIT 等 2 MSL 的目的不是限制服务端只能发 2 次 FIN，而是为了让所有可能的 FIN/ACK 报文在网络中完全消失。服务端实际能发几次 FIN，取决于它的重传策略和超时时间，而不是 MSL。


## 比如在服务端在1.5MSL时发送连接释放请求，而ACK 在网络里最多存活 1 MSL，那么等待该ACK失效，已经超过了2MSL，这和你说的客户端等待 2 MSL，只是保证无论如何，旧连接的报文都消失是否吗矛盾呢？

TIME_WAIT 的 2 MSL 是动态的，从最后一个 ACK 算起。
客户端每次发送 ACK，2 MSL 计时都需要重新开始。如果在 TIME_WAIT 期间又收到了 FIN，客户端会重发 ACK，并 刷新计时器。



## tcp的三次握手中，只有第三次客户端可携带数据，那么为什么第一次握手客户端要携带seq号？

客户端第一次握手虽然不能携带数据，但必须带上初始序列号 ISN，原因是：

- 建立序列号基准，让服务端知道后续数据应该从哪开始确认。

- 防止旧连接报文干扰，通过随机 ISN 区分新旧连接。

- 保证握手对称性，让服务端能在第二次握手中确认客户端的 ISN。


## 第一次握手客户端要携带seq号是为了建立序列号基准，那么第一次握手携带的字节数据是多少呢，是1字节？

结论：
- 第一次握手的 SYN 报文并不携带真实数据，数据部分为 0 字节；
- 但它会占用一个序列号，因此客户端的下一个有效序列号是 ISN+1。
- 这是 TCP 的规定：SYN 和 FIN 标志各自消耗一个序列号空间，即使不传数据。

解释：
在 TCP 中，SYN 和 FIN 标志位本身不携带数据，但会消耗一个序列号。

- SYN 消耗 1 序号

- FIN 消耗 1 序号

- ACK（无数据）不消耗序号

- 数据段消耗对应字节数的序号


## 第三次握手客户端可带数据，也可不带数据。如果不带数据，需要传递seq吗？

总结：
- 第三次握手 一定会带 seq，无论有没有数据。

- 如果不带数据，seq=x+1（SYN 占用的序号+1）。

- 如果带数据，从 x+1 开始编号，服务端根据 ack 确认。

解释：
无论是否携带数据，TCP 报文段的首部里一定有 Sequence Number（32 位，4 字节）字段。
所以 第三次握手一定会带 seq，这是 TCP 头部的标准部分，不是可选的。

如果第三次握手 不带数据

- 报文格式：ACK=1，seq=x+1，ack=y+1

- 其中 seq=x+1 的意思是：客户端上一次的 SYN 已经占用了一个序列号，现在下一个要使用的序号是 x+1。

- 虽然没有数据，但仍要显式传递 seq，这是 TCP 协议保证序号连续性的需要。


如果第三次握手 带数据

- 报文格式：ACK=1，seq=x+1，ack=y+1，payload=n bytes

- 这时数据会从 x+1 开始编号，最后一个字节编号是 x+n。

- 服务端收到后，就会 ack=x+1+n。



## 那么无论第三次是否携带数据，那么连接建立后，数据都从seq = x+2开始？

错误

结论： 三次握手后，应用层数据从 seq = x+1 开始，而不是 x+2。


解释： 
情况一：第三次握手不携带数据

1.第一次握手：客户端 → 服务端

- SYN=1, seq=x

- 消耗一个序号 → 下一个是 x+1

2.第二次握手：服务端 → 客户端

- SYN=1, ACK=1, seq=y, ack=x+1

- 服务端 ISN = y，消耗一个序号 → 下一个是 y+1

3.第三次握手：客户端 → 服务端

- ACK=1, seq=x+1, ack=y+1

- 这里没有数据，不额外消耗序号

所以，  连接建立后，客户端应用层第一个字节的数据就是 seq=x+1。


情况二：第三次握手携带数据

1.前两步同上。

2.第三次握手：客户端 → 服务端

- ACK=1, seq=x+1, ack=y+1, [data]

- 数据从 x+1 开始编号

- 如果携带 n 字节数据，那么占用的序号范围是 [x+1, x+n]

- 客户端下一个可用序号就是 x+1+n

所以，  所以应用层数据的起点依然是 x+1，只是这部分数据被“捎带”在第三次握手里了。






简述常见的 HTTP 状态码的含义（301，304，401，403）？

301 Moved Permanently
请求资源的 URL 已永久更改。在响应中给出了新的 URL。

304 Not Modified
这是用于缓存的目的。它告诉客户端响应还没有被修改，因此客户端可以继续使用相同的缓存版本的响应。

401 Unauthorized
虽然 HTTP 标准指定了"unauthorized"，但从语义上来说，这个响应意味着"unauthenticated"。也就是说，客户端必须对自身进行身份验证才能获得请求的响应。

403 Forbidden
客户端没有访问内容的权限；也就是说，它是未经授权的，因此服务器拒绝提供请求的资源。与 401 Unauthorized 不同，服务器知道客户端的身份。

404 Not Found
服务器找不到请求的资源。在浏览器中，这意味着无法识别 URL。在 API 中，这也可能意味着端点有效，但资源本身不存在。

405 Method Not Allowed
服务器知道请求方法，但目标资源不支持该方法。例如，API 可能不允许调用DELETE来删除资源。

500 Internal Server Error
服务器遇到了不知道如何处理的情况。

